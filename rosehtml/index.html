<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> A beautiful rose for a beautiful person ðŸŒ¹</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            background: #000;
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
    <!-- Canvas Container -->
    <div id="three-container"></div>

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
        }
    }
    </script>

    <!-- Main Three.js Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a1a, 10, 25);
        
        // Camera
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 4, 12);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        
        document.getElementById('three-container').appendChild(renderer.domElement);
        
        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.minDistance = 4;
        controls.maxDistance = 25;
        controls.maxPolarAngle = Math.PI / 1.8;
        
        
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // strength
            0.4, // radius
            0.85 // threshold
        );
        composer.addPass(bloomPass);
        
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xff3366, 1.5);
        mainLight.position.set(8, 12, 5);
        mainLight.castShadow = true;
        mainLight.shadow.camera.left = -10;
        mainLight.shadow.camera.right = 10;
        mainLight.shadow.camera.top = 10;
        mainLight.shadow.camera.bottom = -10;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(-5, 3, -5);
        scene.add(fillLight);
        
        const rimLight = new THREE.DirectionalLight(0xff6699, 0.8);
        rimLight.position.set(0, 2, -10);
        scene.add(rimLight);
        
        const pointLight1 = new THREE.PointLight(0xdc143c, 1.2, 15);
        pointLight1.position.set(5, 3, 3);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xff3366, 0.8, 12);
        pointLight2.position.set(-4, 2, -4);
        scene.add(pointLight2);
        
        const roseGroup = new THREE.Group();
        roseGroup.name = "cyberRose";
        
        const petalMaterial = new THREE.MeshStandardMaterial({
            color: 0xdc143c,
            roughness: 0.3,
            metalness: 0.8,
            side: THREE.DoubleSide,
            emissive: 0x330000,
            emissiveIntensity: 0.2,
            flatShading: false
        });
        
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6699,
            wireframe: true,
            transparent: true,
            opacity: 0.15,
            emissive: 0xff3366,
            emissiveIntensity: 0.2
        });
        
        const petalGeometry = new THREE.SphereGeometry(1, 32, 32, 0, Math.PI, 0, Math.PI); 
        petalGeometry.scale(1, 1, 0.4);
        
    
        function createPetal(y, angle, scale, xOffset, rotationX) {
            const petal = new THREE.Mesh(petalGeometry, petalMaterial);
            petal.castShadow = true;
            petal.receiveShadow = true;
            
            const wireframe = new THREE.Mesh(petalGeometry, wireframeMaterial);
            wireframe.scale.set(1.01, 1.01, 1.01);
            petal.add(wireframe);
            
            const pivot = new THREE.Object3D();
            pivot.rotation.y = angle;
            
            petal.position.x = xOffset;
            petal.position.y = y;
            petal.scale.set(scale, scale, scale);
            petal.rotation.x = rotationX;
            petal.rotation.z = Math.PI / 2;
            
            pivot.add(petal);
            roseGroup.add(pivot);
            
            return { petal, wireframe };
        }
        
    
        const petals = [];
        const totalPetals = 34;
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));
        
        for (let i = 0; i < totalPetals; i++) {
            const angle = i * goldenAngle;
            const ratio = i / totalPetals;
            
            const y = 2 - (ratio * 1.8);
            const scale = 0.5 + (ratio * 0.9);
            const xOffset = 0.2 + (ratio * 1.2);
            const rotationX = (Math.PI / 5) + (ratio * Math.PI / 2.5);
            
            const petalObj = createPetal(y, angle, scale, xOffset, rotationX);
            petals.push(petalObj);
        }
        
      
        const stemGeometry = new THREE.CylinderGeometry(0.12, 0.18, 7, 16);
        const stemMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x228b22, 
            roughness: 0.7,
            metalness: 0.3,
            emissive: 0x113311,
            emissiveIntensity: 0.1
        });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.y = -2.5;
        stem.castShadow = true;
        roseGroup.add(stem);
        
        
        const leafGeometry = new THREE.SphereGeometry(0.7, 24, 24);
        leafGeometry.scale(1, 0.08, 2);
        const leafMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x32cd32, 
            roughness: 0.6,
            metalness: 0.2,
            side: THREE.DoubleSide 
        });
        
        const leaf1 = new THREE.Mesh(leafGeometry, leafMaterial);
        leaf1.position.set(0.6, -1.2, 0);
        leaf1.rotation.set(0.5, 0.5, 0);
        leaf1.castShadow = true;
        roseGroup.add(leaf1);
        
        const leaf2 = new THREE.Mesh(leafGeometry, leafMaterial);
        leaf2.position.set(-0.7, -2.2, 0.3);
        leaf2.rotation.set(0.5, -2, 0);
        leaf2.castShadow = true;
        roseGroup.add(leaf2);
        
        scene.add(roseGroup);
        
      
        let time = 0;
        let pulseBase = 1;
        let pulseDirection = 0.002;
        
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
    
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            controls.update();
            
            
            pulseBase += pulseDirection;
            if (pulseBase > 1.03 || pulseBase < 0.97) {
                pulseDirection *= -1;
            }
            
            roseGroup.scale.set(pulseBase, pulseBase, pulseBase);
            
            
            petals.forEach((petalObj, i) => {
                const petal = petalObj.petal;
                const speed = 0.5 + (i % 3) * 0.2;
                petal.rotation.y += Math.sin(time * speed) * 0.001;
            });
            
            
            pointLight1.position.x = 5 + Math.sin(time * 0.5) * 2;
            pointLight1.position.y = 3 + Math.cos(time * 0.3) * 1.5;
            
            pointLight2.position.z = -4 + Math.sin(time * 0.4) * 2;
            pointLight2.position.y = 2 + Math.cos(time * 0.5) * 1;
            
            composer.render();
        }
        
        
        animate();
    </script>
</body>
</html>S